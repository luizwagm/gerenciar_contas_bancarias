{"ast":null,"code":"/**\n * Returns the formatted time zone name of the provided `timeZone` or the current\n * system time zone if omitted, accounting for DST according to the UTC value of\n * the date.\n */\nexport function tzIntlTimeZoneName(length, date, options) {\n  const dtf = getDTF(length, options.timeZone, options.locale);\n  return 'formatToParts' in dtf ? partsTimeZone(dtf, date) : hackyTimeZone(dtf, date);\n}\nfunction partsTimeZone(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  for (let i = formatted.length - 1; i >= 0; --i) {\n    if (formatted[i].type === 'timeZoneName') {\n      return formatted[i].value;\n    }\n  }\n  return undefined;\n}\nfunction hackyTimeZone(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, '');\n  const tzNameMatch = / [\\w-+ ]+$/.exec(formatted);\n  return tzNameMatch ? tzNameMatch[0].substr(1) : '';\n}\n// If a locale has been provided `en-US` is used as a fallback in case it is an\n// invalid locale, otherwise the locale is left undefined to use the system locale.\nfunction getDTF(length, timeZone, locale) {\n  return new Intl.DateTimeFormat(locale ? [locale.code, 'en-US'] : undefined, {\n    timeZone: timeZone,\n    timeZoneName: length\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}