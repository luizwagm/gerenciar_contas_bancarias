{"ast":null,"code":"/**\n * Returns the [year, month, day, hour, minute, seconds] tokens of the provided\n * `date` as it will be rendered in the `timeZone`.\n */\nexport function tzTokenizeDate(date, timeZone) {\n  const dtf = getDateTimeFormat(timeZone);\n  return 'formatToParts' in dtf ? partsOffset(dtf, date) : hackyOffset(dtf, date);\n}\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  hour: 3,\n  minute: 4,\n  second: 5\n};\nfunction partsOffset(dtf, date) {\n  try {\n    const formatted = dtf.formatToParts(date);\n    const filled = [];\n    for (let i = 0; i < formatted.length; i++) {\n      const pos = typeToPos[formatted[i].type];\n      if (pos !== undefined) {\n        filled[pos] = parseInt(formatted[i].value, 10);\n      }\n    }\n    return filled;\n  } catch (error) {\n    if (error instanceof RangeError) {\n      return [NaN];\n    }\n    throw error;\n  }\n}\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const parsed = /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(formatted);\n  // const [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed\n  // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]\n  return [parseInt(parsed[3], 10), parseInt(parsed[1], 10), parseInt(parsed[2], 10), parseInt(parsed[4], 10), parseInt(parsed[5], 10), parseInt(parsed[6], 10)];\n}\n// Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used\n// to get deterministic local date/time output according to the `en-US` locale which\n// can be used to extract local time parts as necessary.\nconst dtfCache = {};\nfunction getDateTimeFormat(timeZone) {\n  if (!dtfCache[timeZone]) {\n    // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`\n    const testDateFormatted = new Intl.DateTimeFormat('en-US', {\n      hourCycle: 'h23',\n      timeZone: 'America/New_York',\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit'\n    }).format(new Date('2014-06-25T04:00:00.123Z'));\n    const hourCycleSupported = testDateFormatted === '06/25/2014, 00:00:00' || testDateFormatted === '‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00';\n    dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat('en-US', {\n      hourCycle: 'h23',\n      timeZone: timeZone,\n      year: 'numeric',\n      month: 'numeric',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit'\n    }) : new Intl.DateTimeFormat('en-US', {\n      hour12: false,\n      timeZone: timeZone,\n      year: 'numeric',\n      month: 'numeric',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit'\n    });\n  }\n  return dtfCache[timeZone];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}