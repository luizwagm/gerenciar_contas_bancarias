{"ast":null,"code":"import { tzTokenizeDate } from '../tzTokenizeDate/index.js';\nimport { newDateUTC } from '../newDateUTC/index.js';\nconst MILLISECONDS_IN_HOUR = 3600000;\nconst MILLISECONDS_IN_MINUTE = 60000;\nconst patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-]\\d{2})$/,\n  timezoneHHMM: /^([+-])(\\d{2}):?(\\d{2})$/\n};\n// Parse constious time zone offset formats to an offset in milliseconds\nexport function tzParseTimezone(timezoneString, date, isUtcDate) {\n  // Empty string\n  if (!timezoneString) {\n    return 0;\n  }\n  // Z\n  let token = patterns.timezoneZ.exec(timezoneString);\n  if (token) {\n    return 0;\n  }\n  let hours;\n  let absoluteOffset;\n  // ±hh\n  token = patterns.timezoneHH.exec(timezoneString);\n  if (token) {\n    hours = parseInt(token[1], 10);\n    if (!validateTimezone(hours)) {\n      return NaN;\n    }\n    return -(hours * MILLISECONDS_IN_HOUR);\n  }\n  // ±hh:mm or ±hhmm\n  token = patterns.timezoneHHMM.exec(timezoneString);\n  if (token) {\n    hours = parseInt(token[2], 10);\n    const minutes = parseInt(token[3], 10);\n    if (!validateTimezone(hours, minutes)) {\n      return NaN;\n    }\n    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset;\n  }\n  // IANA time zone\n  if (isValidTimezoneIANAString(timezoneString)) {\n    date = new Date(date || Date.now());\n    const utcDate = isUtcDate ? date : toUtcDate(date);\n    const offset = calcOffset(utcDate, timezoneString);\n    const fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);\n    return -fixedOffset;\n  }\n  return NaN;\n}\nfunction toUtcDate(date) {\n  return newDateUTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n}\nfunction calcOffset(date, timezoneString) {\n  const tokens = tzTokenizeDate(date, timezoneString);\n  // ms dropped because it's not provided by tzTokenizeDate\n  const asUTC = newDateUTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();\n  let asTS = date.getTime();\n  const over = asTS % 1000;\n  asTS -= over >= 0 ? over : 1000 + over;\n  return asUTC - asTS;\n}\nfunction fixOffset(date, offset, timezoneString) {\n  const localTS = date.getTime();\n  // Our UTC time is just a guess because our offset is just a guess\n  let utcGuess = localTS - offset;\n  // Test whether the zone matches the offset for this ts\n  const o2 = calcOffset(new Date(utcGuess), timezoneString);\n  // If so, offset didn't change, and we're done\n  if (offset === o2) {\n    return offset;\n  }\n  // If not, change the ts by the difference in the offset\n  utcGuess -= o2 - offset;\n  // If that gives us the local time we want, we're done\n  const o3 = calcOffset(new Date(utcGuess), timezoneString);\n  if (o2 === o3) {\n    return o2;\n  }\n  // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time\n  return Math.max(o2, o3);\n}\nfunction validateTimezone(hours, minutes) {\n  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);\n}\nconst validIANATimezoneCache = {};\nfunction isValidTimezoneIANAString(timeZoneString) {\n  if (validIANATimezoneCache[timeZoneString]) return true;\n  try {\n    new Intl.DateTimeFormat(undefined, {\n      timeZone: timeZoneString\n    });\n    validIANATimezoneCache[timeZoneString] = true;\n    return true;\n  } catch (error) {\n    return false;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}